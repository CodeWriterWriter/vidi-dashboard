'use strict'

var Influx = require('influx')
var _ = require('lodash')
var Async = require('async')

// Our defaults.
var defaults = {
  host: 'localhost',
  port: 8086,
  username: 'msgstats',
  password: 'msgstats',
  database: 'seneca_msgstats'
}

// This plugin provides handlers to query data generated by
// seneca-msgstats. Data is queried and presented in such
// a way as to make it easy for charting apps to consume.
module.exports = function (options) {
  var seneca = this
  var extend = seneca.util.deepextend

  // merge user options, create db instance
  options = extend(defaults, options)
  var db = Influx(options)

  // Since this is reporting plugin, any errors will just be noted. Pulling down
  // the whole system because of one metric failing to read isn't a great idea.
  function noteFailure (err, done) {
    if (err) {
      seneca.log.error(err.stack)
    }

    done(null, null)
  }

  function makeCombinedFlowRate (data) {
    var points = data[0] || []

    points.forEach(function (point) {
      point.x = new Date(point.time).getTime()
      point.y = point.sum || 0

      delete point.time
      delete point.sum
    })

    return _.sortBy(points, 'x')
  }

  function makeCombinedBreakdown (data) {
    var counts = data[1] || []
    var rates = data[2] || []
    var labels = ['Service', 'Rate', 'Count']
    var values = []

    var totalCount = 0
    var totalRate = 0

    rates.forEach(function (rate) {
      var tag = rate.tag
      var msgRate = rate.sum
      var msgCount = _.filter(counts, function (count) {
        return count.tag === tag
      })[0].sum || 0

      totalRate = totalRate + msgRate
      totalCount = totalCount + msgCount

      values.push([tag, msgRate, msgCount])
    })

    values.push(['Totals', totalRate, totalCount])

    return {
      labels: labels,
      values: values
    }
  }

  function makeFlowRateBreakdownPin (data) {
    var counts = data[3] || []
    var rates = data[4] || []
    var labels = ['Pin', 'Rate', 'Count']
    var values = []

    var totalCount = 0
    var totalRate = 0

    console.log(data[3], data[4])

    rates.forEach(function (rate) {
      var pin = rate.pin
      var msgRate = rate.sum
      var msgCount = _.filter(counts, function (count) {
        return count.pin === pin
      })[0].sum || 0

      totalRate = totalRate + msgRate
      totalCount = totalCount + msgCount

      values.push([pin, msgRate, msgCount])
    })

    values.push(['Totals', totalRate, totalCount])

    return {
      labels: labels,
      values: values
    }
  }

  function sanitizeFlowPerService (data) {

    var points = data || []
    var services = {}

    points.forEach(function (point) {
      var service = services[point.tag] || {}

      service.label = (point.tag)
      service.values = service.values || []

      var value = {
        x: new Date(point.time).getTime(),
        y: point.sum || 0
      }

      service.values.push(value)
      service.values = _.sortBy(service.values, 'x')
      services[point.tag] = service
    })

    return services
  }

  function makePerTagAndPidFlowRate (data) {
    var points = data || []
    var series = {}

    points.forEach(function (point) {
      var label = (point.tag + ": " + point.pid)
      var current = series[label] || {}

      current.label = label
      current.values = current.values || []

      var value = {
        x: new Date(point.time).getTime(),
        y: point.sum || 0
      }

      current.values.push(value)
      current.values = _.sortBy(current.values, 'x')
      series[label] = current
    })

    return series
  }

  function makeFlowPerPin (data) {

    var points = data || []
    var services = {}

    points.forEach(function (point) {
      var service = services[point.pin] || {}

      service.label = (point.pin)
      service.values = service.values || []

      var value = {
        x: new Date(point.time).getTime(),
        y: point.sum || 0
      }

      service.values.push(value)
      service.values = _.sortBy(service.values, 'x')
      services[point.pin] = service
    })

    return services
  }

  function sanitizeServiceInfo (data) {
    var points = data || []
    var labels = ['Service', 'Count']
    var values = []

    points.forEach(function (point) {
      values.push([point.tag, point.sum])
    })

    return {
      labels: labels,
      values: values
    }
  }

  // Returns a dataset containing a rolling flow rate for every msg captured
  // by seneca-msgstats.
  seneca.add({role: 'metrics', source: 'msgstats', metric: 'rolling_flow_rate'},
    function (msg, done) {
      var payload = {
        'flow_rate_per_service': [],
        'flow_rate_per_pin': [],
        'flow_rate_per_tag_and_pid': []
      }

      var query =
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 120s  GROUP BY time(1s);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 120s  GROUP BY "tag" fill(0);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 1s  GROUP BY "tag" fill(0);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 120s  GROUP BY "pin" fill(0);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 1s  GROUP BY "pin" fill(0);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 120s  GROUP BY "tag", time(1s);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 120s GROUP BY "pid", "tag", time(1s);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 120s  GROUP BY "pin", time(1s);' +
        'SELECT SUM(available) as free, SUM(used) as used FROM mem_stats WHERE time > now() - 1s  GROUP BY "tag", "pid" fill(0)'

      db.query(query, function (err, data) {
        if (err || !data) {
          return noteFailure(err, done)
        }

        payload['flow_rate_combined'] =  {label: 'flow_rate_combined', values: makeCombinedFlowRate(data)}
        payload['flow_rate_combined_breakdown'] = makeCombinedBreakdown(data)
        payload['flow_rate_breakdown_pin'] = makeFlowRateBreakdownPin(data)

        var perServiceFlowRates = sanitizeFlowPerService(data[5])
        _.each(perServiceFlowRates, function (serviceRate) {
          payload['flow_rate_per_service'].push(serviceRate)
        })

        var perTagAndPids = makePerTagAndPidFlowRate(data[6])
        _.each(perTagAndPids, function (perTagAndPid) {
          payload['flow_rate_per_tag_and_pid'].push(perTagAndPid)
        })

        var flowPerPin = makeFlowPerPin(data[7])
        _.each(flowPerPin, function (flow) {
          payload['flow_rate_per_pin'].push(flow)
        })

        payload['service_info'] = sanitizeServiceInfo(data[8])

        return done(null, {data:payload})
      })
    })

  // Allows realtime communication hook up, we
  // are essentially declaring our metrics to
  // anyone who wants to 'subscribe' to it.
  seneca.publish({
    role: 'metrics',
    cmd: 'sub',
    source: 'msgstats',
    metric: 'rolling_flow_rate'
  })

  // At minimum seneca needs the name of our
  // plugin so it can correctly manage it.
  return {
    name: 'vidi-msgstats-metrics'
  }
}
