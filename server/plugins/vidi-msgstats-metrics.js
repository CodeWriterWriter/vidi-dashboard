'use strict'

var Influx = require('influx')
var _ = require('lodash')

// Our defaults.
var defaults = {
  host: 'localhost',
  port: 8086,
  username: 'msgstats',
  password: 'msgstats',
  database: 'seneca_msgstats'
}

// This plugin provides handlers to query data generated by
// seneca-msgstats. Data is queried and presented in such
// a way as to make it easy for charting apps to consume.
module.exports = function (options) {
  var seneca = this
  var extend = seneca.util.deepextend

  // merge user options, create db instance
  options = extend(defaults, options)
  var db = Influx(options)

  function noteFailure (err, done) {
    if (err) {
      seneca.log.error(err.stack || err)
    }

    done(err, {data: null})
  }

  function makeCombinedFlowRate (data) {
    var points = data[0] || []

    points.forEach(function (point) {
      point.x = new Date(point.time).getTime()
      point.y = point.sum || 0

      delete point.time
      delete point.sum
    })

    return _.sortBy(points, 'x')
  }

  function makeCombinedBreakdown (data) {
    var rates = data[2] || []
    var labels = ['Service', 'Rate']
    var values = []

    var totalRate = 0

    rates.forEach(function (rate) {
      var tag = rate.tag
      var msgRate = rate.sum

      totalRate = totalRate + msgRate

      values.push([tag, msgRate])
    })

    values.push(['Totals', totalRate])

    return {
      labels: labels,
      values: values
    }
  }

  function makeFlowRateBreakdownPin (data) {
    var rates = data[4] || []
    var labels = ['Pin', 'Rate']
    var values = []

    var totalRate = 0

    rates.forEach(function (rate) {
      var pin = rate.pin
      var msgRate = rate.sum
      totalRate = totalRate + msgRate

      values.push([pin, msgRate])
    })

    values.push(['Totals', totalRate])

    return {
      labels: labels,
      values: values
    }
  }

  function sanitizeFlowPerService (data) {
    var points = data || []
    var services = {}

    points.forEach(function (point) {
      var service = services[point.tag] || {}

      service.label = (point.tag)
      service.values = service.values || []

      var value = {
        x: new Date(point.time).getTime(),
        y: point.sum || 0
      }

      service.values.push(value)
      service.values = _.sortBy(service.values, 'x')
      services[point.tag] = service
    })

    return services
  }

  function makePerTagAndPidFlowRate (data) {
    var points = data || []
    var series = {}

    points.forEach(function (point) {
      var label = (point.tag + ': ' + point.pid)
      var current = series[label] || {}

      current.label = label
      current.values = current.values || []

      var value = {
        x: new Date(point.time).getTime(),
        y: point.sum || 0
      }

      current.values.push(value)
      current.values = _.sortBy(current.values, 'x')
      series[label] = current
    })

    return series
  }

  function makePerTagAndPidMemRate (data) {
    var points = data || []
    var series = {}

    points.forEach(function (point) {
      var label = (point.tag + ': ' + point.pid)

      var current = series[label] || {
        label: label,
        data: [
          {label: (label + '-free'), values: []},
          {label: (label + '-used'), values: []}
        ]
      }

      var free = {
        x: new Date(point.time).getTime(),
        y: parseInt(point.free, 10) || 0
      }

      while (free.y > 1024) {
        free.y = free.y / 1024
      }
      free.y = Math.floor(free.y)

      var used = {
        x: new Date(point.time).getTime(),
        y: parseInt(point.used, 10) || 0
      }

      while (used.y > 1024) {
        used.y = used.y / 1024
      }
      used.y = Math.floor(used.y)

      current.data[0].values.push(free)
      current.data[1].values.push(used)

      current.data[0].values = _.sortBy(current.data[0].values, 'x')
      current.data[1].values = _.sortBy(current.data[1].values, 'x')

      series[label] = current
    })

    return series
  }

  function makeFlowPerPin (data) {
    var points = data || []
    var services = {}

    points.forEach(function (point) {
      var service = services[point.pin] || {}

      service.label = (point.pin)
      service.values = service.values || []

      var value = {
        x: new Date(point.time).getTime(),
        y: point.sum || 0
      }

      service.values.push(value)
      service.values = _.sortBy(service.values, 'x')
      services[point.pin] = service
    })

    return services
  }

  function makeRatioPerPin (data) {
    var points = data || []
    var services = {}

    points.forEach(function (point) {
      var service = services[point.pin] || {}

      service.label = (point.pin)
      service.values = service.values || []

      var value = {
        x: new Date(point.time).getTime(),
        y: point.mean || 0
      }

      service.values.push(value)
      service.values = _.sortBy(service.values, 'x')
      services[point.pin] = service
    })

    return services
  }

  // Returns a dataset containing a rolling flow rate for every msg captured
  // by seneca-msgstats.
  seneca.add({role: 'metrics', source: 'msgstats', metric: 'rolling_flow_rate'},
    function (msg, done) {
      var payload = {
        'flow_rate_per_service': [],
        'flow_rate_per_pin': [],
        'flow_rate_per_tag_and_pid': [],
        'mem_usage_per_tag_and_pid': [],
        'ratio_per_pin': []
      }

      var query =
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 120s  GROUP BY time(1s);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 120s  GROUP BY "tag" fill(0);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 1s  GROUP BY "tag" fill(0);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 120s  GROUP BY "pin" fill(0);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 1s  GROUP BY "pin" fill(0);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 120s  GROUP BY "tag", time(1s);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 120s GROUP BY "pid", "tag", time(1s);' +
        'SELECT SUM(count) FROM msg_stats WHERE time > now() - 120s  GROUP BY "pin", time(1s);' +
        'SELECT SUM(available) as free, SUM(used) as used FROM mem_stats WHERE time > now() - 120s  GROUP BY "tag", "pid", time(1s)' +
        'SELECT MEAN(count) FROM msg_ratios WHERE time > now() - 120s  GROUP BY "pin", time(1s) fill(0);'

      db.query(query, function (err, data) {
        if (err || !data) {
          return noteFailure(err, done)
        }

        payload['flow_rate_combined'] = {label: 'flow_rate_combined', values: makeCombinedFlowRate(data)}
        payload['flow_rate_combined_breakdown'] = makeCombinedBreakdown(data)
        payload['flow_rate_breakdown_pin'] = makeFlowRateBreakdownPin(data)

        var perServiceFlowRates = sanitizeFlowPerService(data[5])
        _.each(perServiceFlowRates, function (serviceRate) {
          payload['flow_rate_per_service'].push(serviceRate)
        })

        var perTagAndPids = makePerTagAndPidFlowRate(data[6])
        _.each(perTagAndPids, function (perTagAndPid) {
          payload['flow_rate_per_tag_and_pid'].push(perTagAndPid)
        })

        var flowPerPin = makeFlowPerPin(data[7])
        _.each(flowPerPin, function (flow) {
          payload['flow_rate_per_pin'].push(flow)
        })

        var perTagAndPidMems = makePerTagAndPidMemRate(data[8])
        _.each(perTagAndPidMems, function (perTagAndPids) {
          payload['mem_usage_per_tag_and_pid'].push(perTagAndPids)
        })

        var countPin = makeRatioPerPin(data[9])
        _.each(countPin, function (flow) {
          payload['ratio_per_pin'].push(flow)
        })

        return done(null, {data: payload})
      })
    })

  // Allows realtime communication hook up, we
  // are essentially declaring our metrics to
  // anyone who wants to 'subscribe' to it.
  seneca.publish({
    role: 'metrics',
    cmd: 'sub',
    source: 'msgstats',
    metric: 'rolling_flow_rate'
  })

  // At minimum seneca needs the name of our
  // plugin so it can correctly manage it.
  return {
    name: 'vidi-msgstats-metrics'
  }
}
